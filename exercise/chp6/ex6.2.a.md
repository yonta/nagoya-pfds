不変条件の変更から、負債不変条件を以下のように書き換える。

D(i) <= min (2i, 2|f|-|r|)

このminの引数は、前者が先頭ノードが負債0を保証し、後者がcheck関数によって回転が
起こる際にはキュー全体の負債がすべて返済されていることを保証する。

（ただし、今回の不変条件から、2iの部分はfloor(3/2*i)まで詰めることができる。
  またここから一般化することで、a|f|-b|r|への不変条件の変更は、負債不変条件を
  min (1 + b/a, a|f|-b|r|)へと拡張できそうだと考える。）

実装より、checkによるキューの回転によって、++が負債|f|、reverseが負債|r|を
それぞれつくる。
ここで、snoc/tailは実装から非共有部が定数時間で動作する。
よって、snoc/tailが定数値の負債返済するだけで上記の不変条件が満たされていれば、
snoc/tailの償却上限がO(1)であることを示せる。
これから、それを証明する。

ここからは、snocとtailがそれぞれによって1と2の負債を返済することで、上記の
負債不変条件を維持することしめす。

まず、checkによる回転が起こらないsnocを考える。
これは定理6.1の証明と同じである。

次に、checkによる回転が起こらないtailを考える。
これは|f|を1減らすため、2iと2|f|-|r|のどちらの計算結果も2減らす。
よって、tailは2の負債返済で十分である。

次に、checkによる回転が起こるsnocを考える。
つまり、checkの動作時に、ある自然数mに対して、|f|=2mかつ|r|=m+1のときである。
このときのd(i)とD(i)を考えると、
  d(i) = 1   (i < 2m)
       = m+1 (i = 2m)
       = 0   (i > 2m)
  D(i) = i + 1  (i < 2m)
       = 3m + 1 (i >= 2m)
となる。
よって、負債不変条件を満たさない瞬間はi=0のときだけであるため、
snocが負債を1返済すれば負債不変条件を満たす。

最後に、checkによる回転が起こるtailを考える。
つまり、checkの動作時に、ある自然数mに対して、|f|=2m-1かつ|r|=mのときである。
このときのd(i)とD(i)を考えると、
  d(i) = 1   (i < 2m-1)
       = m   (i = 2m-1)
       = 0   (i > 2m-1)
  D(i) = i + 1  (i < 2m-1)
       = 3m - 1 (i >= 2m-1)
よって、負債不変条件を満たさない瞬間はi=0のときだけであるため、
tailが負債を1以上返済すれば負債不変条件を満たす。

よって、snoc/tailがそれぞれ1/2の負債を返済すれば、負債不変条件が満たされ、
償却上限がO(1)となる。
