# (a)

償却コストを支払いきれなくなる反例をあげて証明する。

空のキュー対して自然数をsnocし続ける操作とその結果のキューを、
下記のように定義する。

```
q_0 = empty
q_n = snoc (q_{n-1}, n)
```

このとき`q_6`へsnocして`q_7`を作ることを考える

すると、

```
q_6 = ([1], 3, $([1] @ rev [3, 2]), 3, [6, 5, 4])
```

であり、

```
q_7 = snoc (q_6, 7)
    = check ([1], 3, $([1] @ rev [3, 2]), 4, [7, 6, 5, 4])
    = checkw ([1, 2, 3], 7, $([1, 2, 3] @ rev [7, 6, 5, 4]), 0, [])
    = ([1, 2, 3], 7, $([1, 2, 3] @ rev [7, 6, 5, 4]), 0, [])
```

である。

一方で、checkのときにforce fせずwを書き換えしない場合のq_7'を考えると、

```
q_7' = snoc (q_6, 7)
     = check ([1], 3, $([1] @ rev [3, 2]), 4, [7, 6, 5, 4])
     = checkw ([1], 7, $(force ($([1] @ [3, 2])) @ rev [7, 6, 5, 4]), 0, [])
     = ([1], 7, $(force ($([1] @ [3, 2])) @ rev [7, 6, 5, 4]), 0, [])
```

である。

これらの`q_7`と`q_7'`の違いは、wの中身と、fの中身である。
また、どちらも`@ rev [7, 6, 5, 4]`の債務を負っている。

この`q_7'`に1回のtailすることを考える。
tailを行うと、先頭のwが空となり、checkrによるforce fが動作する。
すると、fの後半部である`@ rev [7, 6, 5, 4]`にもforceが行われる。
しかし、snocとtailはそれぞれ債務（ポテンシャルの変化量）を1と2しか返せないため、
`q_7'`を作る際の1回のsnocと、`q_7'`への1回のtailでは債務を3しか返せない
よって、この`@ rev [7, 6, 5, 4]`部の4の債務は返済しきれない。

さらに、この`@ rev [7, 6, 5, 4]`部はキューの長さの半分であり、
他の考える`q_n`においてキューの長さに比例して債務が大きくなっていく。
一方で、債務を返済する機会は、1回のsnocとtailのみで、定数回だけである。
よって、ポテンシャル関数を変更しsnocとtailの債務の返済量の定数を変えたとしても対処できない。

よって、問題(a)による変更を加えると、tailがO(n)償却時間となってしまう。

# (b)

償却コストを支払いきれなくなる反例をあげて証明する。

まず、checkwを定義しなおす。
tlを使わないため、checkwは以下のように修正される。
force fをした後に、現在のlenfから正しいwを計算する必要がある。

```
fun calcW (lenf, f) = List.drop (f, length f - lenf)
fun checkw ([], lenf, f, lenr, r) =
  let
    val f' = force f
  in
    (calcW f', lenf, f, lenr, r)
  end
  | checkw q = q
```

元のtailはtlを遅延していたため、1の債務を作っていた。
しかし、変更したtailはcalcWをするためにlength関数を使うため、
キューの長さに比例した実コストが発生する可能性がある。

よって、このcalcWが動作するような`q_n`に対するtailを繰り返す呼び出すことで、
O(1)償却時間が壊れてしまう。

具体的には、任意の下記のようなキューに対してtailしたときである。

```
q_n = ([w1], lenf, f, lenr, r)
```
