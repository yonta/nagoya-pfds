一般性を失わずに、昇順リストで示す。
（[1,2,3,4,...]のようなリスト）
リストのサイズに対する帰納法で示す。

まず、補題として、昇順リストに対して`fromList`によって作られるスプレイヒープは、
右部分木方向にだけ伸び続けることを示す。

1. リストのサイズが0のとき

明らかに成り立つ

2. リストサイズがkのとき

```sml
fun fromList nil = empty
  | fromList (x::xs) = insert (x, fromList xs)
```

k-1のサイズのリストに対する`fromList`は右方向にだけに伸び続けている。
ここに、xをinsertすることを考える。
このとき、リストは昇順を仮定しているため、`fromList xs`の任意の要素よりもxは小さい。
よって、partitionは`else`パターンの`E`パターンとなり、
`fromList xs`で作られたリストを右部分木とする、右に伸び切ったスプレイヒープを作る。


次に`fromList`がO(n)のコストなことを示す。

1. リストのサイズが0のとき

明らかにO(n)

2. リストのサイズがkのとき

```sml
fun fromList nil = empty
  | fromList (x::xs) = insert (x, fromList xs)
```

fromListの実装を見ると、再帰呼出しされている。
よって、帰納法の仮定より、`fromList xs`はk−1の長さに対してO(n)のコストがかかる。
そこにinsertすることを考える。

先の補題より、右方向に伸び続けることがわかっているため、insertのコストは1である。
よって、全体のコストはリストサイズkに対してkのみかかり、オーダーはO(n)となる。
